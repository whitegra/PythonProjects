# -*- coding: utf-8 -*-
"""Linear Regression: Predicting Stock Price

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1MmzlNLqTcOXmG0ShUpTZ-hGlZN3uEWQV
"""

import yfinance as yf
import numpy as np

df = yf.download('^GSPC',start='2019-01-01')

df

# Returns of prior end days
df['returns'] = np.log(df.Close.pct_change() + 1)

# Data frame as argument, looping for 'i' in range
def lagit(df, lags):
  names = []
  for i in range(1,lags +1):
      df['Lag_'+str(i)] = df['returns'].shift(i) # shifting each row by one in loop
      names.append('Lag_'+str(i))
  return names # To return names of the lags

# Independant Variables
lagnames = lagit(df,4)
df

df.dropna(inplace=True)

from sklearn.linear_model import LinearRegression
model = LinearRegression()

model.fit(df[lagnames], df['returns'])

# Use linear regression model to predict independant variables (lagnames)
df['prediction_LR'] = model.predict(df[lagnames])

# predicting price is bear or bull
df['direction_LR'] = [1 if i > 0 else -1 for i in df.prediction_LR]

# Muliplying price with return column
df['strat_LR'] = df['direction_LR'] * df['returns']

np.exp(df[['returns', 'strat_LR']].sum())

# To plot
np.exp(df[['returns', 'strat_LR']].cumsum()).plot()

# Split data to train set
from sklearn.model_selection import train_test_split

# Data before 2018 as training data, after 2018 as testing data
train,test = train_test_split(df, shuffle=False,
                              test_size=0.305, random_state=0)  #so data can be replicated

# To avoid warning messages
train = train.copy()
test = test.copy()

model = LinearRegression()

train

# fit model to training set, train returns as dependant variable
model.fit(train[lagnames], train['returns'])

test['predict_LR'] = model.predict(test[lagnames])

# testing direction of the market
test['direction'] = [1 if i > 0 else -1 for i in test.prediction_LR]

test['strat_LR'] = test['direction_LR'] * test['returns']
np.exp(test[['returns','strat_LR']].sum())

# Determine number of trades needed to acheive this preformance(30% more strat_LR #)
# +1 = transaction(direction_LR)
# You are only making a transaction when there is a difference in consecutive values

#'TRUE' counts = trades needed to acheive this preformance
(test['direction_LR'].diff() != 0).value_counts()

np.exp(test[['returns','strat_LR']].cumsum()).plot()